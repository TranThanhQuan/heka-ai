                PROJECT ECOMMER VSHOP
                    laravel 10 + Vue3

** Tạo dự án **
- cách 1: tạo dự án với laravel/installer (mặc định cài laravel phiên bản mới nhất)
    composer global require laravel/installer

    laravel new example-app

    + chọn breeze
    + starterkit vue

- cách 2: cài thủ công (có thể tùy chọn phiên bản laravel)
    composer create-project laravel/laravel ten_project "10.*"

    cd ten_project

    Cài đặt Laravel Breeze
            composer require laravel/breeze --dev

    Cài đặt Breeze với Vue
            php artisan breeze:install vue

    Cài đặt NPM Packages và build
            npm install && npm run dev


** Config **
    - .env
    - database, chạy migrate
    - Tạo .htaccess file
            <IfModule mod_rewrite.c>
                RewriteEngine On

                # Rewrite all requests to the public directory
                RewriteRule ^(.*)$ public/$1 [L]
            </IfModule>

** Chỉnh sửa database **
    - Thêm vào migrateion tạo table user
        $table->boolean('isAdmin')->default(0);

    - xóa table và chạy lại
        php artisan migrate:fresh
        php artisan migrate




** Kiểm tra quyền khi truy cập admin   **
    - Tạo AdminMiddleware để kiểm tra trước khi truy cập vào route admin
        php artisan make:middleware AdminMiddleware

    - viết phương thức kiểm tra có phải là admin không
        public function handle(Request $request, Closure $next , $guard = null): Response
            {
                // nếu đã đăng nhập và là admin
                if (Auth::check() && Auth::user()->isAdmin == 1){
                    return $next($request);
                }

                return redirect()->route('home')->with('error', 'Access Denied, you are not an administrator');

            }



    - khai báo middleware trong kennel
            protected $middlewareAliases = [
                ...
                'admin' => \App\Http\Middleware\AdminMiddleware::class,
            ];


    - Tạo Admin controller trong folder Admin
        php artisan make:controller Admin/AdminController



    - Viết Route chứa middleware để kiểm tra
        Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
            Route::get('/dashboard', [AdminController::class, 'index'])->name('admin.dashboard');
        });






** Admin login/logout **

    - Tạo redirectAdmin middleware để chuyển hướng admin
        php artisan make:middleware redirectAdmin

    - Viết phương thức chuyển hướng nếu là admin
        public function handle(Request $request, Closure $next): Response
            {
                // kiểm tra người dùng có đăng nhập hay chưa và có phải admin thì chuyển hướng về dashboard của admin
                if(Auth::guard('$guard')->check() && Auth::user()->isAdmin == 1){
                    return redirect()->route('admin.dashboard');
                }

                return $next($request);
            }

    - khai báo middleware trong kennel

            use App\Http\Middleware\redirectAdmin;
            protected $middlewareAliases = [
                ...
                'redirectAdmin' => redirectAdmin::class,
            ];

    - Tạo AdminAuthController
        php artisan make:controller Admin/AdminAuthController

        public function showLoginForm(){
            // hiển thị giao diện login bằng vue (/resource/js/Pages/Admin/Auth)
            return Inertia::render('Admin/Auth/Login');
        }

        public function login(Request $request){
            //check if user is an admin and redirect
            if (Auth::attempt(['email' => $request->email, 'password' => $request->password, 'is_admin' =>true])){
                return redirect()->route('admin.dashboard');
            }

            return redirect()->route('admin.login')->with('error', 'Thông tin đăng nhập không hợp lệ');
        }

        public function logout(Request $request){
            Auth::guard('web')->logout();
            $request->session()->invalidate();  // hủy session hiện tại
            return redirect()->route('admin.login');
        }


    - Tạo roure admin login/logout
        Route::group(['prefix' => 'admin' , 'middleware' => 'redirectAdmin'],function () {
            Route::get('login', [AdminAuthController::class, 'showLoginForm'])->name('admin.login');
            Route::post('login', [AdminAuthController::class, 'login'])->name('admin.login.post');
            Route::post('logout', [AdminAuthController::class, 'logout'])->name('admin.logout');
        });

    - Tạo View form login Vue
        + Tạo file vue (/resource/js/Pages/Admin/Auth/Login.vue)
        + Copy nội dung từ file (/resource/js/Pages/Auth/Login.vue) bỏ qua file vừa tạo

        + Thay đổi route để post form


            const submit = () => {
                // đổi route mới 'admin.login.post
                form.post(route('admin.login.post'), {
                    onFinish: () => form.reset('password'),
                });
            };



** Tạo file Dashboard Admin **
    - Tạo file vue (/resource/js/Pages/Admin/Dashboard.vue)
        <template>
            <div>
                <h1>Admin Dashboard</h1>
            </div>
        </template>

        <script setup>

        </script>

    - gọi đến file dashboard trong AdminController
        public function index(){
                return Inertia::render('Admin/Dashboard');
            }

** Cài Flowbite để lấy UI từ Flowbite **
    npm install flowbite

    - Thêm vào tailwind.config.js
        + require('flowbite/plugin')    ---->     plugins: [forms, require('flowbite/plugin')],
        + './node_modules/flowbite/**/*.js'   --->  content: [
                                                        ...
                                                        './node_modules/flowbite/**/*.js'
                                                    ],

    - chạy lại npm run dev


** Thêm giao diện admin từ Flowbite **
    - chọn 1 block giao diện trong https://flowbite.com/blocks/
    - VD chọn https://flowbite.com/blocks/application/shells/
    - copy code bỏ vào template của Dashboard.vue
    - Thêm đoạn dưới để load hiệu ứng
        <script setup>

            import { onMounted } from 'vue'
            import { initFlowbite } from 'flowbite'

            // initialize components based on data attribute selectors
            onMounted(() => {
                initFlowbite();
            })

        </script>


    - Phân tách giao diện thành các thành phần nhỏ có thể sử dụng lại
        + Tạo folder Admin/components
        + Tạo file Navbar.vue, Sidebar.vue, Footer.vue
        + AdminLayout.vue chứa các component của Navbar, Sidebar, Footer đã phần tách
                    <template>
                        <div class="antialiased bg-gray-50 dark:bg-gray-900">
                            <!-- Navbar -->
                            <Navbar />
                            <!-- End Navbar -->

                            <!-- Sidebar -->
                            <Sidebar/>
                            <!-- End Sidebar -->

                            <main class="p-4 md:ml-64 h-auto pt-20">
                                <slot />
                            </main>
                        </div>
                    </template>

                    <script setup>
                        import { onMounted } from "vue";
                        import { initFlowbite } from "flowbite";
                        import Navbar from "./Navbar.vue";
                        import Sidebar from "./Sidebar.vue";


                        // initialize components based on data attribute selectors
                        onMounted(() => {
                            initFlowbite();
                        });
                    </script>


        + Dashboard.vue chứa nội dung Main và gọi AdminLayout vào
                    <template>
                        <AdminLayout>
                            <main>
                                ...
                            </main>
                        </AdminLayout>
                    </template>

                    <script setup>
                        // gọi AdminLayout
                        import AdminLayout from "./AdminLayout.vue";
                    </script>


        *Note:
            - Thẻ <slot></slot> được sử dụng trong component để xác định một vùng chèn nội dung (content insertion point). Đây là một phần quan trọng của slot-based content distribution và được sử dụng để chèn nội dung từ bên ngoài vào component con, cho phép các component trở nên linh hoạt và tái sử dụng.

            - Cách hoạt động của <slot></slot>
                + Component cha (Parent): Khi bạn sử dụng một component và muốn chèn nội dung cụ thể vào trong nó, bạn có thể đặt nội dung đó giữa thẻ mở và đóng của component.
                + Component con (Child): Thẻ <slot></slot> trong component con sẽ là nơi hiển thị nội dung mà component cha truyền vào.

** Thay đổi route button logout **
    - ở Navbar thanh đổi thẻ a của button logout thành Link (dùng route Link)
            <li>
                 // gọi đến name của route
                <Link :href="route('logout')" method="post"
                    class="block py-2 px-4 text-sm hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white" >Log Out
                </Link>
            </li>

    - Khai báo Link ở script
        <script setup>
            import { Link } from "@inertiajs/vue3";
        </script>



**  Thiết kế Database **
    https://dbdiagram.io/d/ecommerce-vshop-6778d7295406798ef73fab8d

    - tables: categories, brands, product_images, cart_items, order_items, user_addresses, users, orders, payments

** Tạo các model cần thiết **
    - các model cần thiết: Category, Brand, ProductImage, Order, OrderItem, CartItem, Product, UserAddress, User, Payment
        php artisan make:model category -m (-m để tạo thêm migration)

    *Note: đặt tên model theo số ít thì migration sẽ tự động đặt số nhiều



** Tạo migration **



** Tạo seeder **
    - Tạo seeder AdminSeeder
        php artisan make:seeder AdminSeeder

        public function run(): void
            {
                User::create([
                    'name' => 'Admin',
                    'email' => 'admin@gmail.com',
                    'password' => Hash::make('123456789'),
                    'isAdmin' => 1,
                ]);
            }

    - Tương tự tạo seeder BrandSeeder, CategorySeeder, ProductSeeder
    - Sử dụng laravel Sluggable để tạo slug thân thiện với SEO
        composer require spatie/laravel-sluggable

        + import vào trong model (product, blog, ...)

            use Spatie\Sluggable\HasSlug;
            use Spatie\Sluggable\SlugOptions;

            class Product extends Model
                {
                    use HasSlug;
                    use HasFactory;

                    protected $fillable = [ 'title', 'slug', 'description', 'published', 'inStock', 'price', 'created_by', 'updated_by', 'deleted_by',];

                    public function getSlugOptions() : SlugOptions
                    {
                        return SlugOptions::create()
                            ->generateSlugsFrom('title')
                            ->saveSlugsTo('slug');
                    }
                }




** Hiển thị danh sách sản phẩm ở admin dashboard

    - Sidebar xóa các thành phần không cần thiết, để lại Dashboard, Page(Product, Brand, Category)
        + Thay đổi thẻ a thành Link, href thành :href="route('...')" và import vào script
            import {Link} from '@inertiajs/vue3';

    - Tạo /Admin/ProductController,
        php artisan make:controller Admin/ProductController

        public function index(){
            // trỏ đến file view
            return Inertia::render('Admin/Product/Index');
        }

    - Tạo route cho admin product
        Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
            ...
            // product
            Route::get('/products', [ProductController::class, 'index'])->name('admin.products.index');

        });

    - Tạo view cho admin product
        + Tạo file /Product/Index.vue (/resources/js/pages/Admin/Product)
        + Tạo component Product List cho admin product
                . Tạo file Admin/Product/ProductList.vue (cùng cấp với file Index phía trên)
                . chọn 1 block giao diện trong https://flowbite.com/blocks/
                . VD chọn https://flowbite.com/blocks/application/advanced-tables/
                . copy code bỏ vào template của file vừa tạo

        + import AdminLayout và ProductList vào page product
                <script setup>
                    import AdminLayout from '../Components/AdminLayout.vue'
                    import ProductList from './ProductList.vue'
                <style lang="scss" scoped>

        + Gọi Admin Layout vào page product
            <template>
                <AdminLayout>
                    <ProductList>

                    </ProductList>
                </AdminLayout>
            </template>


    - Đẩy dữ liệu từ DB ra view
        + Lấy dữ liệu từ ProductController
            public function index(){
                //lấy tất cả các bản ghi từ bảng products
                //Kết quả trả về là một tập hợp (collection) chứa tất cả các đối tượng Product.
                $products = Product::get();
                $brands = Brand::get();
                $categories = Category::get();
                // render component với tham số là 'products' với giá trị là kết quả lấy từ table
                return Inertia::render('Admin/Product/Index', ['products' => $products]);
            }


        + ở view ProductList.vue lấy dữ liệu hiển thị ra màn hình bằng vòng lặp
            <script setup>
                import { usePage } from '@inertiajs/vue3';

                const products = usePage().props.products;
                console.log(products);
            </script>



** add new product **
    - Tạo route
            Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
                ...
                // product
                Route::get('/products', [ProductController::class, 'index'])->name('admin.products.index');
                Route::post('/products/store', [ProductController::class, 'store'])->name('admin.products.store');
                ...
            });

    - Tạo phương thức store trong ProductController

            use Illuminate\Support\Str;
            use App\Models\ProductImage;

            public function store(Request $request){
                $product = new Product();

                $product->title = $request->title;
                $product->description = $request->description;
                $product->price = $request->price;
                $product->quantity = $request->quantity;
                $product->category_id = $request->category_id;
                $product->brand_id = $request->brand_id;

                $product->save();

                //check if product has images uploaded

                if($request->hasFile('product_images')){
                    $productImages = $request->file('product_images');
                    foreach($productImages as $image){
                        //generate a unique name for the image using timestamp and random string
                        $uniqueName = time() . '-' . Str::random(10) . '-' .$image->getClientOriginalExtension();

                        //store the image in the public folder with the unique name
                        $image->move('product_images', $uniqueName);

                        //create a new ProductImage record with the product id and unique name
                        ProductImage::create([
                            'product_id' => $product->id,
                            'image' => 'product_images/' .$uniqueName,
                        ]);
                    }
                }

                return redirect()->route('admin.products.index')->with('success', 'Thêm sản phẩm thành công!');

            }


    - Tạo phương thức quan hệ giữa Product và ProductImage (1-N) (1sp có nhiều hình ảnh)
        + Modal ProductImage.php

            public function product(){
                return $this->belongTo(Product::class);
            }

        + Modal Product
            public function product_images(){
                return $this->hasMany(ProductImage::class);
            }

    - Tạo phương thức quan hệ giữa Category và Product (1-N) (1 cate có nhiều sp)
        + Modal Product
            public function category(){
                return $this->belongsTo(Category::class);
            }

        + Modal category
            public function product(){
                return $this->hasMany(Product::class);
            }

    - Tạo phương thức quan hệ giữa Brand và Product (1-N) (1 brand có nhiều sp)
        + Modal Product
            public function brand(){
                return $this->belongsTo(Brand::class);
            }

        + Modal Brand
            public function product(){
                return $this->hasMany(Product::class);
            }


    - Thêm thư viện tọ slug vào các modal caregory, brand, product
                use Spatie\Sluggable\HasSlug;
                use Spatie\Sluggable\SlugOptions;

                class TênMdal extends Model
                {
                    use hasSlug;
                    use HasFactory;

                    protected $fillable = ['name', 'slug'] ;// các trường cần lấy dữ liệu


                    public function getSlugOptions() : SlugOptions
                    {
                        return SlugOptions::create()
                            ->generateSlugsFrom('name') // slug được tạo từ trường ...
                            ->saveSlugsTo('slug');  // lưu slug vào trường ...
                    }
                }

** Tạo Modal add/edit product **
    - Dùng thư viện element-plus
        https://element-plus.org/en-US/component/upload.html

    - cài element-plus.org
        npm install element-plus --save

    - import to global
        + app.js
            import ElementPlus from 'element-plus'
            import 'element-plus/dist/index.css'

            ...
            setup({ el, App, props, plugin }) {

                app.use(VueSweetalert2)
                window.Swal = app.config.globalProperties.$swal
            },

    - Sử dụng dialog để mở modal
        + https://element-plus.org/en-US/component/dialog.html
                    <el-dialog v-model="dialogVisible" title="Tips" width="500" :before-close="handleClose" >
                        <span>This is a message</span>
                        <template #footer>
                        <div class="dialog-footer">
                            <el-button @click="dialogVisible = false">Cancel</el-button>
                            <el-button type="primary" @click="dialogVisible = false">
                            Confirm
                            </el-button>
                        </div>
                        </template>
                    </el-dialog>

        + ProductList:
            <template>
                //bỏ đoạn el-dialog vào đây
            </template>


        + Tắt Mở modal
            <script setup>
                import {ref} from 'vue';
                const dialogVisible = ref(false);

                //open add modal
                const openAddModal = () => {
                    dialogVisible.value = true;

                }
                //close add modal

            </script>


    - Thêm form add/edit vào modal
        https://flowbite.com/docs/components/forms/

        + Chọn 1 form và thay vào nội dung dialog

    - Tạo function tắt mở form add/edit
        <script>

                const isAddProduct = ref(false);    // biến check modalAdd
                const editMode = ref(false);        // biến check modalEdit
                const dialogVisible = ref(false);   // biến tắt mở modal

                //modal add
                const openAddModal = () => {
                    isAddProduct.value = true;
                    dialogVisible.value = true;
                    editMode.value = false;
                }

                const openEditModal = (product) => {
                    editMode.value = true;
                    isAddProduct.value = false;
                    dialogVisible.value = true;
                }
        </script>


    - Title của modal
        Dùng biến editMode để check

            :title="editMode ? 'Edit product' : 'Add product'"

    - Gọi function openEditModal vào button Edit
            <button @click="openEditModal(product)" class="block py-2 px-4 hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white">
                Edit
            </button>

    - Tạo dữ liệu từ form để hiển thị
            //product form data
                const id = ref('');
                const title = ref('');
                const price = ref('');
                const quantity = ref('');
                const description = ref('');
                const product_images = ref([]);
                const published = ref('');
                const category_id = ref('');
                const brand_id = ref('');
                const inStock = ref('');

    - import sweatalert để hiển thị thông báo
        npm i vue-sweetalert2

        + app.js
            import VueSweetalert2 from 'vue-sweetalert2';
            import 'sweetalert2/dist/sweetalert2.min.css';

            ...


            setup({ el, App, props, plugin }) {
                const app = createApp({ render: () => h(App, props)})

                app.use(plugin)
                app.use(ZiggyVue)
                app.use(ElementPlus)
                app.mount(el)
            },


    - Tạo các thông báo tạm thời (flash messages) lưu trong session
        Http/Middleware/HandleInertiaRequests.php
            public function share(Request $request): array
            {
                return [
                    ...parent::share($request),
                    'auth' => [
                        'user' => $request->user(),
                    ],
                    // flash message
                    'flash' => [
                        'success' => fn () => $request->session()->get('success'),
                        'error' => fn () => $request->session()->get('error'),
                        'warning' => fn () => $request->session()->get('warning'),
                        'info' => fn () => $request->session()->get('info'),
                    ],
                ];
            }

    - Tạo phương thức reset form sau khi thêm

            // reset data after add
            const resetFormData = () => {
                id.value = '';
                title.value = '';
                price.value = '';
                quantity.value = '';
                description.value = '';
                productImages.value = [];
            }

    - Tạo phương thức để Post dữ liệu form
        const AddProduct = async () => {
            const formData = new FormData(); // tạo form

            formData.append('title', title.value);
            formData.append('price', price.value);
            formData.append('quantity', quantity.value);
            formData.append('description', description.value);
            formData.append('category_id', category_id.value);
            formData.append('brand_id', brand_id.value);

            //append product images to the form data
            for (const image of productImages.value) {
                formData.append('product_images[]', image.raw);
            }

            try {
                await router.post('products/store', formData, {
                    onSuccess: page => {
                        Swal.fire({
                            toast: true,
                            icon: 'success',
                            position: 'top',
                            showConfirmButton: false,
                            title: page.props.flash.success,
                        })
                        dialogVisible.value = false;
                        resetFormData();
                    }
                });
            }catch (e) {
                console.log(e);
            }

        }


    - Thay đổi các trường input cho phù hợp
            + sử dụng v-model để gửi data input đến form data
                <form class="max-w-md mx-auto" @submit.prevent = "AddProduct()">

                    ...

                    <div class="relative z-0 w-full mb-5 group">
                        <form class="mx-auto">
                            <label for="description" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Description</label>
                            <textarea v-modal="description" id="description" rows="4" class="block p-2.5 w-full text-sm text-gray-900 bg-gray-50 rounded-lg border border-gray-300 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" placeholder="Leave a description..."></textarea>
                        </form>
                    </div>

                    ...

                    <button type="submit" class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Submit</button>
                </form>


** Upload multiple images **
    - Sử dụng ElementPlus để tạo UI: https://element-plus.org/en-US/component/upload.html
            <el-upload
                v-model:file-list="productImages"   //Kết nối hai chiều (two-way binding) với mảng productImages.
                                                    //chứa danh sách các tệp đã tải lên, mỗi phần tử là một đối tượng chứa thông tin chi tiết của tệp (như tên, URL, trạng thái, v.v.).
                list-type="picture-card"        // Hiển thị danh sách các tệp dưới dạng thẻ hình ảnh (picture card) thay vì dạng danh sách thông thường.
                multiple
                :auto-upload="false"        // Tắt chế độ tự động tải tệp lên server sau khi chọn.
                                            //Tệp sẽ chỉ được tải lên khi người dùng thực hiện hành động cụ thể, ví dụ: nhấn nút xác nhận.
                :on-preview="handlePictureCardPreview" //gọi khi người dùng nhấn vào hình ảnh đã tải lên để xem trước
                :on-remove="handleRemove"           //gọi khi người dùng xóa một tệp khỏi danh sách tải lên
                :on-change="handleFileChange">      //thường được sử dụng để kiểm tra tệp mới hoặc xử lý thông tin trước khi tải lên.
                <el-icon>
                    <Plus />
                </el-icon>
            </el-upload>

    - viết các phương thức để preview, remove, change
        //upload mulitpel images
        const productImages = ref([])
        const dialogImageUrl = ref('')
        const handleFileChange = (file) => {
            console.log(file)
            productImages.value.push(file)
        }

        const handlePictureCardPreview = (file) => {
            dialogImageUrl.value = file.url
            dialogVisible.value = true
        }

        const handleRemove = (file) => {
            console.log(file)
        }


** Show band name, category in dashboard **
    - Tạo phương thức quan hệ giữa Category và Product (1-N) (1 cate có nhiều sp)
        + Modal Product
            public function category(){
                return $this->belongsTo(Category::class);
            }

        + Modal category
            public function product(){
                return $this->hasMany(Product::class);
            }

    - Tạo phương thức quan hệ giữa Brand và Product (1-N) (1 brand có nhiều sp)
        + Modal Product
            public function brand(){
                return $this->belongsTo(Brand::class);
            }

        + Modal Brand
            public function product(){
                return $this->hasMany(Product::class);
            }


    - Gọi object category và brand tại product (controller)

        public function index(){

            $products = Product::with('category','brand')->get(); // dữ liệu trả về sẽ kèm theo object category và brand

            $brands = Brand::get();
            $categories = Category::get();

            return Inertia::render('Admin/Product/Index', ['products' => $products, 'brands' => $brands, 'categories' => $categories]);
        }


    - Gọi category name và brand ở view
            <td class="px-4 py-3">{{ product.category.name }}</td>
            <td class="px-4 py-3">{{ product.brand.name}}</td>



** UI for instock and published status **
    - sử dụng button flowbite để làm UI
    - Dùng v-if, v-else để kiểm tra và thay đổi trạng thái

            <button v-if="product.published == 0" type="button" class="px-3 py-2 text-xs font-medium text-center text-white bg-green-700 rounded-lg hover:bg-green-800 focus:ring-4 focus:outline-none focus:ring-green-300 dark:bg-green-600 dark:hover:bg-green-700 dark:focus:ring-green-800">Published</button>

            <button v-else type="button" class="px-3 py-2 text-xs font-medium text-center text-white bg-red-700 rounded-lg hover:bg-red-800 focus:ring-4 focus:outline-none focus:ring-red-300 dark:bg-red-600 dark:hover:bg-red-700 dark:focus:ring-red-800">UnPublished</button>

    - fill data product
            const openEditModal = (product) => {
                // console.log(product);
                editMode.value = true;
                isAddProduct.value = false;
                dialogVisible.value = true;

                //fill data product
                id.value = product.id;
                title.value = product.title;
                price.value = product.price;
                quantity.value = product.quantity;
                description.value = product.description;
                product_images.value = product.product_images;
                brand_id.value = product.brand_id;
                category_id.value = product.category_id;
                product_images.value = product.product_images;
            }


** edit product with multiple images **
    - Tạo phương thức quan hệ giữa Product và ProductImage (1-N) (1sp có nhiều hình ảnh)
        + Modal ProductImage.php

            public function product(){
                return $this->belongTo(Product::class);
            }

        + Modal Product
            public function product_images(){
                return $this->hasMany(ProductImage::class);
            }

    - lấy ra hình ảnh từ ProductController
        public function index(){

            $products = Product::with('category','brand', 'product_images')->get();
            ...
        }

    - hiển thị ra view
        + dùng block image flowbite
            . Lặp qua mảng product_images lấy ra src
            . button X để xóa ảnh

                <div class="flex flex-nowrap mb-8">
                    <div v-for="(pimage, index) in product_images" :key="pimage.id" class="relative w-32 h-32" >
                        <img class="w-24 h-24 rounded " :src="`/${ pimage.image }`" alt="">
                        <span class="absolute top-0 right-8 transform -translate-y-1/2 w-3.5 h-3.5 bg-red-400 border-2 border-white dark:border-gray-800 rounded-full">
                            <span @click="deleteImage(pimage, index)" class="text-white text-xs font-bold absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">x</span>
                        </span>
                    </div>
                </div>


    - Delete sign product image (xóa ở DB và view)
        + Tạo route
            Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
                ...
                Route::delete('/products/image/{id}', [ProductController::class, 'deleteImage'])->name('admin.products.image.delete');
            });

        + Tạo phương thức trong controller
            public function deleteImage($id){
                $image = ProductImage::where('id', $id)->delete();
                return redirect()->route('admin.products.index')->with('success', 'Xóa ảnh thành công!');
            }

        + function deleteImage ở view

            const deleteImage = async (pimage, index) => {
                    try {
                        await router.delete('/admin/products/image/' + pimage.id, {
                            onSuccess: page => {
                                product_images.value.splice(index, 1); // xóa hình ảnh khỏi mảng

                                Swal.fire({
                                    toast: true,
                                    icon:'success',
                                    position: 'top',
                                    showConfirmButton: false,
                                    title: page.props.flash.success,
                                })
                            }
                        });
                    } catch (e) {
                        console.log(e);
                    }
                }



** Phương thức cập nhật product **
    - Tạo route
            Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
                ...
                Route::put('/products/update/{id}', [ProductController::class, 'update'])->name('admin.products.update');
            });


    - Tạo phương thức controller
        public function update(Request $request, $id){
            $product = Product::findOrFail($id);
            $product->title = $request->title;
            $product->price = $request->price;
            $product->quantity = $request->quantity;
            $product->description = $request->description;
            $product->category_id = $request->category_id;
            $product->brand_id = $request->brand_id;


            // check if product images were uploaded
            if($request->hasFile('product_images')){
                $productImages = $request->file('product_images');
                //lặp qua các hình ảnh  đươc tải lên
                foreach($productImages as $image){
                    //generate a unique name for the image using timestamp and random string
                    $uniqueName = time(). '-' . Str::random(10). '-' .$image->getClientOriginalExtension();

                    //store the image in the public folder with the unique name
                    $image->move('product_images', $uniqueName);

                    //create a new ProductImage record with the product id and unique name
                    ProductImage::create([
                        'product_id' => $product->id,
                        'image' => 'product_images/'. $uniqueName,
                    ]);
                }
            }

            $product->update();

            return redirect()->route('admin.products.index')->with('success', 'Cập nhật sản phẩm thành công!');

        }


    - function update ở view

            const UpdateProduct = async () => {
                const formData = new FormData(); // tạo form

                formData.append('title', title.value);
                formData.append('price', price.value);
                formData.append('quantity', quantity.value);
                formData.append('description', description.value);
                formData.append('category_id', category_id.value);
                formData.append('brand_id', brand_id.value);
                formData.append("_method", 'PUT');

                //append product images to the form data
                for (const image of productImages.value) {
                    formData.append('product_images[]', image.raw);
                }


                try{
                    await router.post('products/update/' + id.value, formData, {
                        onSuccess: page => {
                            dialogVisible.value = false; // đóng modal khi thành công
                            resetFormData();        //reset form data
                            Swal.fire({
                                toast: true,
                                icon:'success',
                                position: 'top',
                                showConfirmButton: false,
                                title: page.props.flash.success,
                            })
                        }
                    });
                }catch(e){
                    console.log(e);
                }
            }


    - Gọi function update khi ở editMode
            <form class="mx-auto" @submit.prevent="editMode ? UpdateProduct() : AddProduct()">
                ...
            </form>


** cập nhật thông tin product list ở dashboard khi chỉnh sửa ** (fix bugs in products list not updated after add or edit product )

    dùng emit props để truyền từ component cha sang component con

    - /product/index.vue
        <script setup>
            defineProps( {
                products: Array
            } );

            ...
        </script>

    - ở component con thay đổi dữ liệu sau đó cập nhật lại component cha
        <script setup>
            defineProps( {
                products: Array
            } );

            ...
        </script>





** Xóa sản phẩm **
    - Tạo route
        Route::middleware(['auth', 'admin'])->prefix('admin')->group(function () {
            ...
            Route::delete('/products/destroy/{id}', [ProductController::class, 'destroy'])->name('admin.products.destroy');
        });

    - Viết phương thức controller
            public function destroy($id){
                $product = Product::findOrFail($id);
                $product->delete();
                return redirect()->route('admin.products.index')->with('success', 'Xóa sản phẩm thành công!');
            }


    - Tạo function ở view
            const deleteProduct = (product, index) => {
                Swal.fire({
                    title: 'Are you sure?',
                    text: "This action cannot be undone!",
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#3085d6',
                    cancelButtonColor: '#d33',
                    confirmButtonText: 'Yes, delete!'
                }).then((result) => {
                    if (result.isConfirmed) {
                        try {
                            router.delete('products/destroy/' + product.id, product, {
                                onSuccess: (page) => {
                                    this.delete(product, index);
                                    Swal.fire({
                                        toast: true,
                                        icon: 'success',
                                        position: 'top',
                                        showConfirmButton: false,
                                        title: page.props.flash.success,
                                    });
                                }
                            });
                        } catch (e) {
                            console.log(e);
                        }
                    }
                });
            };


    - gọi function ở button Delete
            <a href="#" @click="deleteProduct(product, index)" class="block py-2 px-4 text-sm text-gray-700 hover:bg-gray-100 dark:hover:bg-gray-600 dark:text-gray-200 dark:hover:text-white">
                Delete
            </a>






*****************************************
***** XÂY DỰNG GIAO DIỆN TRANG CHỦ ******
*****************************************

- Tạo route
    Route::get('/', [UserController::class, 'index'])->name('user.home');

- Tạo controller
    php artisan make:controller User/UserController

    public function index(){
        // lấy dữ liệu product kèm với các bảng khóa ngoại, giới hạn 8 product
        $products = Product::with('brands', 'category', 'product_images')->limit(8)->get();

        return Inertia::render('User/Index',[
            'canLogin' => app('router')->has('login'),
            'canRegister' => app('router')->has('register'),
            'laravelVersion' => Application::VERSION,
            'phpVersion' => PHP_VERSION,
            'products' => $products, // trả dữ liệu cho frontend
        ]);
    }

   /*       render('User/Index',[...]); ---> laravel gửi dữ liệu backend tới frontend(Vue) thông qua component (User/Index)
    *
    *       // Dữ liệu truyền đến view
    *       // kiểm tra route 'login' có được định nghĩa trong router hay không, trả về true hoặc false, xác định xem người dùng có thể truy cập vào trang đăng nhập hay không.
    *       'canLogin' => app('router')->has('login'),

    *       // tương tự 'login', xác định xem người dùng có thể truy cập vào trang đăng ký hay không.
    *       'canRegister' => app('router')->has('register'),

            // PHP_VERSION: Lấy phiên bản PHP hiện tại đang chạy trên server (ví dụ: 8.2.1).
    *       'laravelVersion' => Application::VERSION,
    *       'phpVersion' => PHP_VERSION,
    *
    *
    *
    *       // Trong Vue.js có thể sử dụng các biến canLogin, canRegister, laravelVersion, và phpVersion để tạo giao diện người dùng
    *
    *
   */

- Config shared data (cấu hình chia sẽ dữ liệu từ backend đến frontend)
    + config trong file HandleInertiaRequests.php tương tự config flash message
        return [
            ...parent::share($request),
            'auth' => [
                'user' => $request->user(),
            ],
            'flash' => [
                ...
            ],

            'canLogin' => app('router')->has('login'),
            'canRegister' => app('router')->has('register'),
            'laravelVersion' => Application::VERSION,
            'phpVersion' => PHP_VERSION,
        ];

    //  được chia sẻ với mọi response từ backend qua Inertia. Khi frontend nhận được response, nó sẽ có thể sử dụng các giá trị này để tùy chỉnh giao diện hoặc hiển thị thông tin cụ thể.





- Tạo view
    + Tạo file Pages/User/Index.vue
        // Các thiết lập Route, Controller bên trên sẽ lấy file này làm Homepage
        // các biến khai báo ở controller cũng sẽ được truyền đến view
        <template>

            <div>
                <h1>This is HomePage</h1>
            </div>

        </template>

        <script setup>

        </script>


- Xây dựng UI HomePage
    + Layout sẽ có dạng

        <!-- header -->             // component header
        <!-- main contain -->
            <!-- hero section -->   // component hero
            <!-- list product -->   // component list product

        <!-- footer -->             // component footer

    + Tạo folder Pages/User/Layouts/ để chứa các component
    + Tạo các file component (header, hero, footer, ...)

        . Chọn block nav làm header và block footer trên flowbite paste vào component tương ứng
             Thêm đoạn dưới để load hiệu ứng
                <script setup>

                    import { onMounted } from 'vue'
                    import { initFlowbite } from 'flowbite'

                    // initialize components based on data attribute selectors
                    onMounted(() => {
                        initFlowbite();
                    })

                </script>

    + main contain sẽ tùy vào nội dung trang chủ
        . có thể tự code các component
        . dùng các block trên flowbite (vd: https://flowbite.com/blocks/marketing/hero/)
        . dùng các template của tailwind (vd: https://tailwindui.com/components/ecommerce/components/product-lists)


    +   Component cha là Index gọi đến component con là UserLayout
            import UserLayout from './Layouts/UserLayout.vue';

    +   Component UserLayout:
        . sẽ gọi các component nhỏ hơn (header, hero, footer,...)
                import Header from './Header.vue';
                import Footer from './footer.vue';
        . chứa <slot></slot> để hiển thị nội dung truyền từ component Index vào (cha truyền vào con)
        . Như vậy UserLayout sẽ chứa các component cố định và nội dung động (danh sách sản phẩm) truyền từ Index vào

    + Dữ liệu động (danh sách sản phẩm ) sẽ được xử lý ở component Index
        . Tạo props để lấy dữ liệu từ controller
            <script>
                //  product list
                defineProps({
                    products: Array
                });
            </script>

        . Fill data to UI
    + Xử lý hình ảnh
        . Sử dụng v-if kiểm tra nếu có hình ảnh thì hiển thị không thì hiển thị mặc định hình ảnh no_image_available

                <img v-if="product.product_images.length > 0" :src="`/${product.product_images[0].image}`" :alt="product.imageAlt" class="aspect-square w-full rounded-md bg-gray-200 object-cover group-hover:opacity-75 lg:aspect-auto lg:h-80" />

                <img v-else src="product_images/no_image_available.jpg" :alt="product.imageAlt" class="aspect-square w-full rounded-md bg-gray-200 object-cover group-hover:opacity-75 lg:aspect-auto lg:h-80" />

        . Nếu nhiều hình ảnh thì hiển  thị ảnh đầu tiên
                :src="`/${product.product_images[0].image}`"



** Authentitcate User Header **
// Hiển thị thông tin user (nếu đã đăng nhập) hoặc button Login|Regisiter (nếu chưa đăng nhập)

- header.vue
    <script>
        import { Link, usePage } from '@inertiajs/vue3';

        const canLogin = usePage().props.canLogin;
        const canRegister = usePage().props.canRegister;
        const auth = usePage().props.auth;

    </script>

    // usePage là một hook của Inertia.js trong Vue 3, dùng để truy cập vào props và meta của trang hiện tại.
    // Các props này thường được truyền từ server-side (Laravel) thông qua Inertia và chứa dữ liệu cần thiết cho trang frontend.


        // nếu cho login
        <div v-if="canLogin">
            <div>
                // btn cart
            </div>


            <!-- if login -> show user info -->
            <button v-if="auth.user" type="button"
                    // user info
            </button>

            <!-- not login -> show  btn login|register -->
            <div v-else>
                <Link :href="route('login')" >Login</Link>

                <!-- check if can register -> show button Registere -->
                <Link v-if="canRegister" :href="route('register')">Register</Link>
            </div>
        </div>


        // không cho login
        <div v-else>

        </div>






//////////////////////////////////////////////////////////
************         ADD TO CART        *****************
/////////////////////////////////////////////////////////

1. Hiển thị button add to cart khi hover vào product

    - Thêm button Pages\User\Index.vue
                        <div
                            class="z-10 aspect-h-1 aspect-w-1 w-full overflow-hidden rounded-mb bg-gray-200 lg:aspect-none group-hover:opacity-75 lg:h-80">
                            <img v-if="product.product_images.length > 0" :src="`/${product.product_images[0].image}`"
                            :alt="product.imageAlt"
                            class="h-full w-full object-cover object-center lg:h-full lg:w-full" />
                            <img v-else src="product_images/no_image_available.jpg" :alt="product.imageAlt"
                                class="h-full w-full object-cover object-center lg:h-full lg:w-full" />


                            <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 " >
                                <div class="bg-blue-700 p-2 rounded-full cursor-pointer" @click="addToCart(product)">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                                        stroke-width="1.5" stroke="currentColor" class="size-6">
                                        <path stroke-linecap="round" stroke-linejoin="round"
                                            d="M15.75 10.5V6a3.75 3.75 0 1 0-7.5 0v4.5m11.356-1.993 1.263 12c.07.665-.45 1.243-1.119 1.243H4.25a1.125 1.125 0 0 1-1.12-1.243l1.264-12A1.125 1.125 0 0 1 5.513 7.5h12.974c.576 0 1.059.435 1.119 1.007ZM8.625 10.5a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm7.5 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
                                    </svg>

                                </div>
                            </div>

                        </div>


    - Hàm addToCart()
        const addToCart = (product) => {
            router.post(route('cart.store', product),{
                onSuccess: (page) => {
                    if (page.props.flash.success){
                        Swal.fire({
                            toast: true,
                            position: 'top',
                            icon:'success',
                            title: page.props.flash.success,
                            showConfirmButton: false,
                        })
                    }
                }
            })
        }




2. Helper
    app/Helper/Cart.php

    1. getCount
        public static function getCount(){
            if($user = auth()->user()){
                return CartItem::whereUserId($user->id)->count();
            }else{
                return array_reduce(self::getCookieCartItems(), fn($carry, $item) => $carry + $item['quantity'], 0);
            }
        }
        Mục đích: trả về tổng số lượng mặt hàng trong giỏ hàng của người dùng:

            - Nếu người dùng đã đăng nhập, nó truy vấn cơ sở dữ liệu để lấy tổng số lượng mặt hàng trong giỏ hàng của người dùng.
            - Nếu người dùng chưa đăng nhập, nó lấy thông tin giỏ hàng từ cookie và tính tổng số lượng mặt hàng trong đó.
                + lặp qua mảng và giảm nó về một giá trị duy nhất. Ở đây, fn($carry, $item) => $carry + $item['quantity'] là một hàm ẩn danh (anonymous function) dùng để cộng dồn số lượng ('quantity') của từng mặt hàng trong giỏ hàng.
                + Tham số cuối cùng 0 là giá trị khởi tạo của biến $carry, nghĩa là tổng bắt đầu từ 0
    2. getCartItems

        public static function getCartItems(){
            if($user = auth()->user() ){
                // đã đăng nhập
                return CartItem::whereUserId($user->id)->get()->map(fn (CartItem $item) => ['product_id' => $item->product, 'quantity' => $item->quantity]);
            }else{
                //chưa đăng nhập
                return self::getCookieCartItems();
            }
        }

        Mục đích: Lấy danh sách các sản phẩm trong giỏ hàng của người dùng đã đăng nhập.
        Hoạt động:
        Kiểm tra xem người dùng có đăng nhập không.
        Truy vấn bảng CartItem để lấy các mục giỏ hàng của người dùng.
        Sử dụng map để định dạng lại kết quả thành mảng với product_id và quantity.
        Kết quả: Một mảng các sản phẩm trong giỏ hàng, mỗi phần tử có dạng:


        ['product_id' => ..., 'quantity' => ...]

    3. getCookieCartItems

        public static function getCookieCartItems(){
            return json_decode(request()->cookie('cart_items', '[]'), true);
        }

        Mục đích: Lấy danh sách sản phẩm từ cookie giỏ hàng của khách (guest).
        Hoạt động:
        Đọc cookie có tên cart_items.
        Chuyển đổi dữ liệu JSON trong cookie thành mảng PHP.
        Kết quả: Mảng các sản phẩm trong giỏ hàng của khách.

    4. setCookieCartItems: lưu trữ giỏ hàng của người dùng dưới dạng một cookie
        public static function setCookieCartItems(array $cartItems){
            Cookie::queue('cart_items', json_encode($cartItems), 60*24*30);
        }
        Mục đích: tạo và lưu cookie với tên là cart_items, giá trị là thông tin giỏ hàng dưới dạng chuỗi JSON, và thời gian hết hạn của cookie là 30 ngày

    5. saveCookieCartItems

        public static function saveCookieCartItems() {
            $user = auth()->user();
            $userCartItems = CartItem::where('user_id', $user->id)->get()->keyBy('product_id');
            ...
        }
        Mục đích: Lưu các sản phẩm từ cookie giỏ hàng vào cơ sở dữ liệu cho người dùng đã đăng nhập.
        Hoạt động:
        Lấy các sản phẩm giỏ hàng hiện tại trong cơ sở dữ liệu của người dùng (userCartItems).
        Lặp qua danh sách sản phẩm trong cookie:
        Nếu sản phẩm đã tồn tại trong cơ sở dữ liệu, cập nhật số lượng (update).
        Nếu không, thêm sản phẩm mới vào danh sách cần lưu ($savedCartItems).
        Lưu danh sách sản phẩm mới vào cơ sở dữ liệu bằng CartItem::insert.
        Kết quả: Đồng bộ hóa sản phẩm từ cookie giỏ hàng vào cơ sở dữ liệu.

    6. moveCartItemsIntoDb

        public static function moveCartItemsIntoDb(){
            $request = request();
            $cartItems = self::getCookieCartItems();
            ...
        }

        Mục đích: Chuyển toàn bộ sản phẩm từ cookie giỏ hàng vào cơ sở dữ liệu cho người dùng đã đăng nhập.
        Hoạt động:
        Lấy danh sách sản phẩm từ cookie giỏ hàng.
        Với từng sản phẩm trong cookie:
        Kiểm tra xem sản phẩm đã tồn tại trong cơ sở dữ liệu chưa.
        Nếu chưa tồn tại, thêm sản phẩm đó vào danh sách cần lưu ($newCartItems).
        Lưu các sản phẩm mới vào cơ sở dữ liệu bằng CartItem::insert.
        Kết quả: Chuyển dữ liệu từ cookie giỏ hàng sang cơ sở dữ liệu, đảm bảo không trùng lặp.

    7.  public static function getProductAndCartItems(){
            $cartItem = self::getCartItems();
            $ids = Arr::pluck($cartItems, 'product_id');
            $products = Product::whereIn('id', $ids)->with('product_images')->get();
            $cartItems = Arr::keyBy($cartItem, 'product_id');
            return [$products, $cartItems];
        }

        lấy danh sách sản phẩm từ cơ sở dữ liệu dựa trên các product_id có trong giỏ hàng.
        Đồng thời, giỏ hàng ($cartItems) được sắp xếp lại để dễ dàng truy xuất thông tin sản phẩm dựa trên product_id.
        Trả về một mảng gồm hai phần:
            Danh sách thông tin chi tiết của các sản phẩm.
            Danh sách các mặt hàng trong giỏ hàng.

3. Tạo controller
    php artisan make:controller User/UserController

    - Tạo các phương thức view, store, update, delete
    - store:
            Đối với người dùng đã đăng nhập:

            Lưu giỏ hàng trong cơ sở dữ liệu (CartItem).
            Kiểm tra xem sản phẩm đã tồn tại hay chưa để cập nhật hoặc tạo mới.
            Đối với người dùng chưa đăng nhập:

            Sử dụng cookie để lưu trữ giỏ hàng.
            Duyệt qua danh sách sản phẩm trong cookie để cập nhật số lượng nếu sản phẩm đã tồn tại, hoặc thêm sản phẩm mới nếu chưa.
            Kết quả:

            Phương thức luôn thêm sản phẩm vào giỏ hàng (trực tiếp hoặc qua cookie).
            Thông báo thành công được hiển thị sau khi hoàn tất.

    - Update
        Đã đăng nhập
            + Xác định sản phẩm trong giỏ hàng:
                Tìm dòng dữ liệu trong bảng CartItem có user_id và product_id tương ứng.
            + Cập nhật số lượng:
                Thay đổi giá trị quantity của sản phẩm thành số lượng mới ($quantity) lấy từ yêu cầu.

        Chưa đăng nhập
            + Lấy giỏ hàng từ cookie:
                Sử dụng Cart::getCookieCartItems() để lấy danh sách giỏ hàng hiện tại từ cookie.
            + Tìm sản phẩm cần cập nhật:
                Duyệt qua danh sách sản phẩm trong cookie.
                Nếu sản phẩm có product_id khớp với sản phẩm cần cập nhật, thay đổi số lượng (quantity) bằng cách cộng thêm số lượng mới.
            + Lưu lại giỏ hàng vào cookie:
                Gọi Cart::setCookieCartItems($cartItems) để lưu danh sách giỏ hàng mới (đã được cập nhật) vào cookie.


    - Delete
        Trường hợp 1: Người dùng đã đăng nhập
            Tìm sản phẩm cần xóa:
                Sử dụng where để tìm dòng dữ liệu trong bảng CartItem có user_id và product_id khớp với người dùng và sản phẩm.
            Xóa sản phẩm:
                Nếu sản phẩm tồn tại (first()), sử dụng delete() để xóa nó.

            Nếu giỏ hàng trống (CartItem::count() <= 0):
                Chuyển hướng người dùng về trang chủ và hiển thị thông báo "Giỏ hàng trống!".
            Nếu giỏ hàng còn sản phẩm:
                Quay lại trang trước đó và hiển thị thông báo "Xóa sản phẩm khỏi giỏ hàng thành công!".

        Trường hợp 2: Người dùng chưa đăng nhập
            Lấy giỏ hàng từ cookie:
                Sử dụng Cart::getCookieCartItems() để lấy danh sách giỏ hàng hiện tại từ cookie.
            Tìm sản phẩm cần xóa:
                Duyệt qua từng sản phẩm trong mảng cartItems.
                Nếu product_id của sản phẩm trong mảng khớp với product->id, sử dụng array_splice để xóa sản phẩm khỏi mảng.
            Lưu lại giỏ hàng vào cookie:
                Sử dụng Cart::setCookieCartItems($cartItems) để lưu lại giỏ hàng mới (sau khi xóa sản phẩm).

            Nếu giỏ hàng trống (count($cartItems) <= 0):
                Chuyển hướng người dùng về trang chủ và hiển thị thông báo "Giỏ hàng trống!".
            Nếu giỏ hàng còn sản phẩm:
                Quay lại trang trước đó và hiển thị thông báo "Xóa sản phẩm khỏi giỏ hàng thành công!".



4. Route
    //add to cart

    Route::prefix('cart')->controller(CartController::class)->group(function () {
        Route::get('view', 'view')->name('cart.view');
        Route::post('store/{product}', 'store')->name('cart.store');
        Route::patch('update/{product}', 'update')->name('cart.update');
        Route::post('delete', 'delete')->name('cart.delete');
    });

5. Thiết lập quan hệ cho modal CartItem với user và cartItem với product

    -  CartItem và user (1-N) (1user có nhiều CartItem)
        + Modal CartItem.php

            public function user(){
                return $this->belongTo(User::class);
            }



    -  CartItem và Product (1-N) (1user có nhiều CartItem)
        + Modal CartItem.php

            public function Product(){
                return $this->belongTo(Product::class);
            }

        + Modal Product
            public function cartItems(){
                return $this->hasMany(CartItem::class);
            }


6. Sử dụng Resource để chuẩn hóa định dạng dữ liệu được trả về
    - HandleInertiaRequests.php

        public function share(Request $request): array
            {
                return [
                    ...parent::share($request),
                    'auth' => [
                        'user' => $request->user(),
                    ],

                    'cart' => new CartResource(Cart::getProductAndCartItems()),

                    ...

                ];
            }



    - Tạo CartResource
        php artisan make:resource CartResource
            public function toArray(Request $request): array
                {
                    [$products, $cartItems] = $this->resource;
                    return [
                        'count' => Cart::getCount(),
                        'total' => $products->reduce(fn (?float $carry, Product $product) => $carry + $product->price * $cartItems[$product->id]['quantity']),
                        'items' => $cartItems,
                        'products' => ProductResource::collection($products),
                    ];
                }


            + $this->resource: Dữ liệu được truyền vào CartResource, ở đây được giả định là một mảng chứa 2 phần tử:
                $product: Danh sách các sản phẩm trong giỏ hàng (dạng collection hoặc array).
                $cartItems: Mảng các thông tin giỏ hàng (bao gồm số lượng, chi tiết sản phẩm...).

            + $product->reduce: Phương thức lặp qua các sản phẩm trong danh sách và thực hiện phép cộng dồn để tính tổng giá trị giỏ hàng.
                fn (?float $carry, Product $product): Closure (hàm ẩn danh), thực hiện tính tổng.
                $carry: Biến lưu trữ tổng giá trị qua mỗi vòng lặp (khởi đầu là null).
                $product: Một sản phẩm trong danh sách.
                $product->price: Giá của sản phẩm.
                $cartItems[$product->id][$quatity]: Lấy số lượng sản phẩm từ mảng $cartItems tương ứng với ID sản phẩm.
                Kết quả: Tổng giá trị giỏ hàng (giá * số lượng).

            + Giải thích
                Phương thức toArray trả về dữ liệu giỏ hàng với các thông tin chính:
                    count: Số lượng sản phẩm trong giỏ hàng.
                    total: Tổng giá trị giỏ hàng.
                    items: Danh sách các mục trong giỏ hàng.
                    products: Danh sách sản phẩm, được định dạng bằng ProductResource.







    - ProductsResource: trả về một mảng chứa các thông tin chi tiết của sản phẩm
        php artisan make:resource ProductResource

            public function toArray(Request $request): array
                {
                    return [
                        'id' => $this->id,
                        'title' => $this->title,
                        'slug' => $this->slug,
                        'description' => $this->description,
                        'price' => $this->price,
                        'quantity' => $this->quantity,
                        'status' => $this->status,
                        'created_at' => $this->created_at,
                        'updated_at' => $this->updated_at,
                        'product_image' => $this->whenLoaded('product_image', function (){
                            return  ProductImageResource::collection($this->product_image);
                        }),
                        'category_id' => $this->category_id,
                        'category' => new CategoryResource($this->whenLoaded('category')),
                        'brand_id' => $this->brand_id,
                        'brand' => new BrandResource($this->whenLoaded('brand')),
                    ];
                }


        +  Hình ảnh sản phẩm

            'product_image' => $this->whenLoaded('product_image', function () {
                return ProductImageResource::colleection($this->product_image);
            }),

            . whenLoaded('product_image'): Chỉ tải và trả về hình ảnh sản phẩm nếu quan hệ product_image đã được load (tránh việc tải không cần thiết).
            . Closure: Nếu quan hệ product_image tồn tại, trả về một tập hợp tài nguyên (ProductImageResource) cho từng hình ảnh trong danh sách + product_image

        + Danh mục sản phẩm

            'category_id' => $this->category_id,
            'category' => new CategoryResource($this->whenLoaded('category')),

            . category_id: ID danh mục của sản phẩm.
            . category: Nếu quan hệ category được load, trả về một tài nguyên CategoryResource


        + Thương hiệu sản phẩm

            'brand_id' => $this->brand_id,
            'brand' => new BrandResource($this->whenLoaded('brand')),

            . brand_id: ID thương hiệu của sản phẩm.
            . brand: Nếu quan hệ brand được load, trả về một tài nguyên BrandResource


    - ProductImageResource: định dạng dữ liệu hình ảnh sản phẩm một cách nhất quán và gọn gàng khi trả về từ API.
            public function toArray(Request $request): array
                {
                    return [
                        'id' => $this->id,
                        'product_id' => $this->product_id,
                        'image' => $this->image,
                    ];
                }

            + id: ID của hình ảnh sản phẩm trong cơ sở dữ liệu.
            + product_id: ID của sản phẩm mà hình ảnh này thuộc về, giúp xác định mối quan hệ giữa hình ảnh và sản phẩm.
            + image: Đường dẫn hoặc URL của hình ảnh.

    - CategoryResource
            public function toArray(Request $request): array
                {
                    return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'slug' => $this->slug,
                    ];
                }

    - BrandResource
            public function toArray(Request $request): array
                {
                    return [
                        'id' => $this->id,
                        'name' => $this->name,
                        'slug' => $this->slug,
                    ];
                }


7. Hiển thị số mặt hàng trong giỏ hàng (cart items)
    - Khởi tạo biến cart
        <script>
            import {computed} from 'vue';

            const cart = computed(()=>usePage().props.cart);
        </script>



**  Quản lý giỏ hàng **
1. Hiển thị giỏ hàng
    - CartController
        // trả về danh sách mặt  hàng trong giỏ hàng và địa chỉ
            public function view(Request $request, Product $product){
                $user = $request->user();

                if($user){
                    /// lấy ra danh sách giỏ hàng của user
                    $cartItems = CartItem::where('user_id', $user->id)->get();
                    // lấy ra địa chỉ giao hàng chính của user
                    $userAddress = UserAddress::where('user_id', $user->id)->where('isMain', 1)->first();

                    if($cartItems->count()>0){
                        // nếu có mặt hàng trong giỏ hàng thì trả về danh sách các mặt hàng và địa chỉ giao hàng chính
                        return Inertia::render('User/CartList',['cartItems'=>$cartItems, 'userAddress'=>$userAddress]);
                    }else{
                        //nếu giỏ hàng trống thì lấy trong cookie
                        $cartItem = Cart::getCookieCartItem();
                        if($cartItems->count()>0){
                            $cartItems = new CartResource(Cart::getProductsAndCartItems());
                            return Inertia::render('User/CartList',['cartItems'=>$cartItems]);
                        }else{
                            return redirect()->back();
                        }
                    }
                }
            }


    - view: Pages/User/Layouts/CartLlayout.vue

        <template>
            <UserLayout>
                <h1>Cart list</h1>
            </UserLayout>
        </template>

        <script setup>
            import UserLayout from './Layouts/UserLayout.vue';
            import { computed } from 'vue';
            import { usePage } from '@inertiajs/vue3';

            const products = computed(() => usePage().props.cart.data.products);
            const total = computed(() => usePage().props.cart.data.total);
            const carts = computed(() => usePage().props.cart.data.items);

        </script>


        + chọn 1 block trong tailblock.cc để làm UI cho giỏ hàng

        + Sử dụng table of product https://flowbite.com/docs/components/tables/ để hiển thị danh sách mặt hàng trong giỏ hàng


2. Hiển thị hình ảnh sản phẩm
    - Kiểm tra nếu sp có ảnh thì hiển thị ảnh đầu tiên còn nếu không thì  hiển thị ảnh no_image_available
            <img v-if="product.product_images.length > 0" :src="`/${product.product_images[0].image}`" class="w-16 md:w-32 max-w-full max-h-full" alt="Product image">

            <img v-else src="/product_images/no_image_available.jpg" class="w-16 md:w-32 max-w-full max-h-full" alt="Product image">


3. Update quantity of product

    <script>
        const itemId = (id) => carts.value.findIndex((item) => item.product_id === id);

        const update = (product, quantity) => router.patch(route('cart.update', product),{
            quantity,
        });
    </script>


        Hàm nhận hai tham số:
            product: Đại diện cho sản phẩm cần cập nhật (thường là một ID hoặc một đối tượng chứa thông tin sản phẩm).
            quantity: Số lượng sản phẩm cần cập nhật.

        router.patch:
            router là một đối tượng có chức năng thực hiện các yêu cầu HTTP (request)
            .patch là dùng để cập nhật dữ liệu trên server.
            ->  gửi một yêu cầu đến server để chỉnh sửa một phần thông tin (trong trường hợp này là số lượng sản phẩm).

        router('cart.update', product):
            router là một phương thức để tạo URL động dựa trên các route trong ứng dụng.
            'cart.update' là tên của route,
            product là tham số truyền vào route (ID hoặc mã định danh của sản phẩm.)


        { quantity }:

            đối tượng chứa giá trị số lượng cần cập nhật.



4. gọi function để tăng giảm số lượng
    - Nút giảm số lượng
        <button
            // gọi function giảm số lượng
            @click.prevent="update(product, carts[itemId(product.id)].quantity - 1)"

            // nếu trong biểu thức = true ( < 1) thì sẽ kích hoạt disabled(vô hiệu hóa)
            :disabled="carts[itemId(product.id)].quantity <= 1"

            // nếu số mặt hàng > 1 thì hiển thị cursor-pointer còn không thì cursor-notallowed
            :class="[carts[itemId(product.id)].quantity > 1 ? 'cursor-pointer text-purple-600' : 'cursor-notallowed text-gray-300 dark:text-gray-500', 'inline-flex items-center justify-center p-1 me-3 text-sm font-medium h-6 w-6 text-gray-500 bg-white border border-gray-300 rounded-full focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700']"
            type="button">



            <span class="sr-only">Quantity button</span>
            <svg class="w-3 h-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 18 2">
                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h16"/>
            </svg>
        </button>


    - hiển thị số lượng mặt hàng
        <input
            v-model="carts[itemId(product.id)].quantity"
            type="number" id="first_product" class="bg-gray-50 w-14 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block px-2.5 py-1 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" placeholder="1" required />


    - Bút tăng số lượng
        <button
            @click.prevent="update(product, carts[itemId(product.id)].quantity + 1)"
            class="inline-flex items-center justify-center h-6 w-6 p-1 ms-3 text-sm font-medium text-gray-500 bg-white border border-gray-300 rounded-full focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700" type="button">
            <span class="sr-only">Quantity button</span>
            <svg class="w-3 h-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 18 18">
                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 1v16M1 9h16"/>
            </svg>
        </button>




** Lọc sản phẩm theo brand, category, giá (cao -> thấp, thấp -> cao) **
1. Controller: ProductListController
    php artisan make:controller User/ProductListController

    public function index(){
        // Lấy toàn bộ sản phẩm từ cơ sở dữ liệu kèm theo quan hệ
        $products = Product::with('category', 'brand' , 'product_images');

        //Áp dụng bộ lọc và phân trang cho danh sách sản phẩm
        $filterProducts = $products->filtered()->paginate(9)->withQueryString();

        // danh sách categories và brands từ DB
        $categories = Category::get();
        $brands = Products::get();

        return Inertia::render('User/ProductList',[
                                                    'products' => ProductResource::collection($filterProducts),
                                                    'categories' => $categories,
                                                    'brands' => $brands
                                                ]);
    }


    . filtered(): Áp dụng các điều kiện lọc (như thương hiệu, danh mục, giá) từ scopeFiltered trong Model.
    . withQueryString(): Giữ nguyên các tham số trong URL khi phân trang (ví dụ: lọc theo thương hiệu, danh mục, giá).
    . Dữ liệu sản phẩm ($filterProducts) được định dạng lại thông qua ProductResource để chuẩn bị hiển thị trên giao diện.


2. route
    // product list and filter
    Route::prefix('products')->controller(ProductListController::class)->group(function () {
        Route::get('/', 'index')->name('products.index');

    });

3. view
    - Button dẫn đến trang product (User/index.vue)
        <Link :href="route('products.index')" class="text-gray-900 bg-gradient-to-r from-teal-200 to-lime-200 hover:bg-gradient-to-l hover:from-teal-200 hover:to-lime-200 focus:ring-4 focus:outline-none focus:ring-lime-200 dark:focus:ring-teal-700 font-medium rounded-lg text-sm px-5 py-2.5 text-center me-2 mb-2">Teal to Lime</Link>

    - Hiển thị trang products
            <template>
                <UserLayout>
                        ...
                </UserLayout>
            </template>

            <script setup>
                import UserLayout from './Layouts/UserLayout.vue';

            </script>

4.Chi tiết trang products
- Sử dụng layoutSidebar : https://tailwindui.com/components/ecommerce/components/category-filters

- import các thư viện cần thiết
    + headlessui vue: npm install @headlessui/vue
    + heroicons vue: npm install @heroicons/vue
    note: chạy lại npm run dev sau khi cài

- Tách Product trang home (/) thành component để tái sử dụng sau đó import vào
    + Tạo file User/Components/Product.vue
        <template>
            // product list


        </template>


        <script setup>
            import { Link, router } from '@inertiajs/vue3';
            defineProps({
                products: Array
            })


            const addToCart = (product) => {
                router.post(route('cart.store', product),{
                    onSuccess: (page) => {
                        if (page.props.flash.success){
                            Swal.fire({
                                toast: true,
                                position: 'top',
                                icon:'success',
                                title: page.props.flash.success,
                                showConfirmButton: false,
                            })
                        }
                    }
                })
            }
        </script>

    + file User/Index.vue
        . Chuyển đoạn product list qua file vừa tạo sau đó thay bằng đoạn sau để import vào
            <!-- product list component -->
            <Products></Products>

            <script>

                import Products from './Components/Products.vue';
            </script>


    + import vào ProductList.vue
            Tương tự như trên

            <products :products="products.data"></products>

            <script>
                import Products from './Components/Products.vue';

                const props = defineProps({
                    products: Array,
                    categories: Array,
                    brands: Array,
                });

            </script>

- Modal Product
    + viết phương thức áp dụng các bộ lọc (filter) cho các truy vấn dựa trên các thông số như brand, category, và price được gửi từ request.
        // fillter for price or categories or brands
            public function scopeFiltered(Builder $quary){
                $quary
                    ->when(request('brands'), function (Builder $q){
                        $q->whereIn('brand_id', request('brands'));
                    })
                    ->when(request('categories'), function (Builder $q){
                        $q->whereIn('category_id', request('categories'));
                    })
                    ->when(request('prices'), function (Builder $q){
                        $q->whereBetween('prices', [
                            request('prices.from', 0),
                            request('prices.to', 100000000),
                        ]);
                    });
            }


        1. scopeFiltered
            Đây là một local scope function trong model Eloquent (có thể là Product, Item, hoặc tương tự).
            Được gọi bằng cách sử dụng cú pháp Model::filtered() trong các truy vấn.
            Nhận một tham số là $query (hoặc $quary như trong đoạn code) để xử lý truy vấn

        2. Các điều kiện trong scopeFiltered:
            Lọc theo brands:

            ->when(request('brands'), function (Builder $q){
                $q->whereIn('brand_id', request('brands'));
            });

            Nếu trong request có tham số brands, hàm sẽ áp dụng điều kiện:
            Lấy các bản ghi có brand_id nằm trong danh sách giá trị của brands.

            Ví dụ request: ?brands[]=1&brands[]=2
            Kết quả: Truy vấn sẽ tìm các bản ghi có brand_id là 1 hoặc 2.


            Lọc theo categories:
                Tương tự brands


            Lọc theo prices:

                ->when(request('prices'), function (Builder $q){
                    $q->whereBetween('prices', [
                        request('prices.from', 0),
                        request('prices.to', 100000000),
                    ]);
                });

            Nếu trong request có tham số prices, áp dụng điều kiện:
                Lấy các bản ghi có giá trị prices nằm trong khoảng từ:
                prices.from (nếu không có mặc định là 0).
                prices.to (nếu không có mặc định là 100000000).

            Ví dụ request: ?prices[from]=1000&prices[to]=5000
                Kết quả: Tìm các bản ghi có prices nằm trong khoảng từ 1000 đến 5000.


        3. Cách sử dụng :
            Hàm scopeFiltered cho phép áp dụng các bộ lọc vào truy vấn một cách linh hoạt, dựa trên tham số trong request.
            Nếu không có tham số tương ứng (brands, categories, prices) trong request, các điều kiện tương ứng sẽ bị bỏ qua.

            sử dụng :        $filterProducts = Product::filtered()->get();

            Kết quả sẽ trả về danh sách sản phẩm được lọc theo các điều kiện đã định nghĩa.



- Pirces range
    + UI
            <div class="flex items-center justify-between space-x-3">
                // from ...
                <div class="basis-1/3">
                    <label for="filters-price-from"
                        class="mb-2 block text-sm font-medium text-gray-900 dark:text-white">
                        From
                    </label>

                    <input type="number" id="filters-price-from" placeholder="Min price"
                        v-model="filterPrices.prices[0]"
                        class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-primary-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-primary-500 dark:focus:ring-primary-500" />
                </div>


                //to ...
                <div class="basis-1/3">
                    <label for="filters-price-to"
                        class="mb-2 block text-sm font-medium text-gray-900 dark:text-white">
                        To
                    </label>

                    <input type="number" id="filters-price-to" placeholder="Min price"
                        v-model="filterPrices.prices[1]"
                        class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-primary-500 focus:ring-primary-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-primary-500 dark:focus:ring-primary-500" />
                </div>


                // button filter
                <SecondaryButtonVue class="self-end" @click="priceFilter()" :disabled="filterPrices.processing">
                    Ok
                </SecondaryButtonVue>


            </div>


    + Các phương thức cần thiết

        import { useForm } from '@inertiajs/vue3';

        const filterPrices = useForm({
            prices:[0, 10000000]
        });


        //method for price filter
        const priceFilter = () => {
            filterPrices.transform((data) => ({
                ...data,
                prices: {
                    from: filterPrices.prices[0],
                    to: filterPrices.prices[1],
                }
            })).get('products');
        }


            . useForm:
                    Đây là một hàm dùng để quản lý trạng thái của form.
                    Nó khởi tạo trạng thái ban đầu với một đối tượng chứa dữ liệu form.
                    Ở đây, prices là một mảng gồm 2 giá trị:
                        prices[0]: Giá trị tối thiểu (default là 0).
                        prices[1]: Giá trị tối đa (default là 10,000,000).


            .   input HTML, v-model="filterPrices.prices[0]" và v-model="filterPrices.prices[1]" liên kết giá trị của các ô nhập liệu với mảng prices.
                Khi người dùng nhập giá trị vào các ô nhập liệu, giá trị trong filterPrices.prices sẽ được tự động cập nhật.


            . Phương thức priceFilter

                transform:

                    Hàm này cho phép chuyển đổi dữ liệu trước khi gửi nó đi.
                    Trong đoạn mã, dữ liệu ban đầu (filterPrices) được chuyển đổi thành một đối tượng mới có dạng:

                        {
                            ...data, // dữ liệu hiện tại của form
                            prices: {
                                from: filterPrices.prices[0], // giá trị từ ô "From"
                                to: filterPrices.prices[1],   // giá trị từ ô "To"
                            }
                        }

                    Dữ liệu prices từ một mảng [min, max] được chuyển thành một đối tượng { from, to }.


                get:
                    Phương thức này gửi một yêu cầu đến route 'products' cùng với dữ liệu form đã được xử lý


                preserveState: true:
                    Giữ nguyên trạng thái hiện tại của form trong quá trình gửi dữ liệu.
                    Nếu không có tùy chọn này, trạng thái của form có thể bị reset hoặc thay đổi khi yêu cầu được gửi đi.

                replaceState: true:
                    Cập nhật URL trình duyệt bằng cách thay thế trạng thái hiện tại (thường sử dụng để cập nhật query string trong URL).




        . Tóm tắt cách hoạt động
            Khi người dùng nhập giá trị:

            Giá trị từ các ô nhập liệu "From" và "To" được lưu vào filterPrices.prices[0] và filterPrices.prices[1] nhờ v-model.
            Khi bấm nút "Ok":

            Gọi hàm priceFilter():
            Biến đổi dữ liệu trong filterPrices:
            Mảng prices ([min, max]) được chuyển thành đối tượng { from, to }.
            Gửi dữ liệu đến endpoint 'products' để thực hiện lọc danh sách sản phẩm.
            Kết quả:

            API nhận được dữ liệu { prices: { from: <min>, to: <max> } }.
            API trả về danh sách sản phẩm được lọc theo khoảng giá mà người dùng đã nhập.



- Category, Brands filter

        const selectedBrands = ref([])
        const selectedCategories = ref([])

        watch(selectedBrands, () => {
            updateFilteredProducts()
        })
        watch(selectedCategories, () => {
            updateFilteredProducts()
        })

        function updateFilteredProducts() {
            router.get('products', {
                brands: selectedBrands.value,
                categories: selectedCategories.value
            }, {
                preserveState: true,
                replace: true
            })
        }



        selectedBrands và selectedCategories:
            Đây là hai biến phản ứng (ref) chứa danh sách các giá trị đã được chọn (danh sách ID của thương hiệu và danh mục).

        Watcher:
            Hai hàm watch theo dõi thay đổi trên selectedBrands và selectedCategories.
            Khi giá trị của một trong hai thay đổi (người dùng chọn/thay đổi checkbox), hàm updateFilteredProducts được gọi.

        Hàm updateFilteredProducts:

            Gửi một yêu cầu GET đến router để cập nhật danh sách sản phẩm được lọc.
            Các tham số gửi đi bao gồm:
                brands: Giá trị của selectedBrands (các thương hiệu được chọn).
                categories: Giá trị của selectedCategories (các danh mục được chọn).
            Tùy chọn:
                preserveState: true: Bảo toàn trạng thái của router (không tải lại toàn bộ trang).
                replace: true: Thay đổi URL mà không ghi vào lịch sử trình duyệt (không tạo bản ghi mới khi thay đổi).



** Check Out **

1. controller
    - trả về user_address ở index (CartController)
    - Tạo checkout controller : php artisan make:controller User/CheckoutController

2. Model
    - Tạo quan hệ giữa user và UserAddress
        + UserAddress
            function user(){
                return $this->belongsto(User::class);
            }

        + User
            function user_address(){
                return $this->hasMany(UserAddress::class);
            }

    - Quan hệ giữa Order và OrderItem
        + Order
            protected $fillable = [ 'total_price', 'status', 'session_id', 'user_address_id', 'created_by', 'updated_by'];
                use HasFactory;

                function order_items(){
                    return $this->hasMany(OrderItem::class);
                }

        + OrderItem
            protected $fillable = [ 'product_id', 'order_id', 'quantity', 'unit_pirce',];
            use HasFactory;

            public function order(){
                return $this->belongsTo(Order::class);
            }

    - Quan hệ giữa OrderItem và Product
        + OrderItem
            public function product(){
                    return $this->belongsTo(Product::class);
                }


        + Product



    - Quan hệ giữa Order và Payment
        + Payment
            protected $fillable = [
                'order_id', 'type', 'amount', 'status','created_by', 'updated_by'
            ];
            use HasFactory;

            public function order(){
                return $this->hasOne(Order::class, 'id' , 'order_id');
            }




3. route
    - cần login để order nên sử dụng chung middleware với profile

        Route::middleware('auth')->group(function () {
            // route profile
                ...


            // checkout
            Route::prefix('checkout')->controller(CheckoutController::class)->group(function () {
                Route::post('order', 'store')->name('checkout.store');
                Route::get('success', 'success')->name('checkout.success');
                Route::get('cancel', 'cancel')->name('checkout.cancel');

            });
        });


4. view
    - hiển thị address nếu đã có address
            <div v-if="userAddress">
                <h2 class="text-gray-900 text-lg mb-1 font-medium title-font">Shippping Address</h2>
                <p class="leading-relaxed mb-5 text-gray-600">{{ userAddress.address1 }}, {{ userAddress.city }}, {{ userAddress.zipcode }}</p>
            </div>


            <div v-else>
                <p class="leading-relaxed mb-5 text-gray-600">Add shipping address to continue</p>
            </div>

    - tạo form check out

        <form @submit.prevent="submit">   // gọi function submit khi submit form

            <div class="relative mb-4">
                    <label for="address1" class="leading-7 text-sm text-gray-600">Address 1</label>

                    <input type="text"
                        id="address1"
                        name="address1"
                        v-model="form.address"  // lấy dữ liệu gán vào form
                        class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-base outline-none text-gray-700 py-1 px-3 leading-8 transition-colors duration-200 ease-in-out">
            </div>

            // các trường input khác



            // btn checkout
            <button v-if="formFilled" class="text-white bg-indigo-500 border-0 py-2 px-6 focus:outline-none hover:bg-indigo-600 rounded text-lg">Checkout</button>

            <button v-else type="submit" class="text-white bg-gray-500 border-0 py-2 px-6 focus:outline-none hover:bg-gray-600 rounded text-lg">Add address to continue</button>



        </form>


        <script setup>
            import { reactive } from 'vue';
            // lấy dữ liệu address từ controller
            defineProps ({
                userAddress: Object
            })

            //form data
            const form = reactive({
                address: null,
                city: null,
                state: null,
                zipcode: null,
                country_code: null,
                address_type: null,
            });


            // check  formFilled
            // nếu tất cả các trường đều điền thì formFilled = true
            // check ở button "checkout"
            const formFilled = computed(() => {
                return (
                        form.address != null &&
                        form.city != null &&
                        form.state!= null &&
                        form.zipcode != null &&
                        form.country_code != null &&
                        form.address_type != null
                    )

            });

            //confirm order
            function submit(){
                console.log(form);
                router.post(route('checkout.store'), {
                    data: {
                        carts: usePage().props.cart.data.items,
                        products: usePage().props.cart.data.products,
                        total: usePage().props.cart.data.total,
                        address: form,
                    },
                });
            }


        </script>























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































